新規git account
Email:自身のメルアド
pass:*~7%X|(a~zDX
username:dev_nanashi

gitの登録とその確認
登録
ユーザー名：git config --global user.name "任意のユーザ名"
Email：git config --global user.email 事前に登録したgithubでのE-mail
エディタ：git config --global core.editer "使用したいエディタ"
確認
自身で登録したgitの設定を確認：git config --list


git　基礎講座
gitはスナップショットで記録する
変更部分のみを丸ごと保存する
以前から変更のない、部分は変わってない過去のバージョン(スナップショット)から取ってきて、現在の新しいバージョンと組み合わせて利用している形になっている
スナップショットはコミットで作成され、ローカルリポジトリに格納される
コミットを辿ることで以前の状態に戻せる
ローカルリポジトリはリモートリポジトリから開発端末などにコピーしたもの、リモートリポジトリはgithub上で公開されている共有するための、本体
ローカルリポジトリはコミットした後のスナップショットの集まりを集積した場所
ワークツリーはローカルの作業場のファイルシステム構造をさしている
変更した内容をリモートに送信する
ワークツリーの内容を変更する
変更した内容を保存する(コミット)：スナップショット　→　ローカルリポジトリ
コミットはワークツリーの内容を保存する行為で保存した単位がスナップショット
コミットの内容をpushする：ローカル　→　リモート
他人の変更を取り込む場合
内容を保存：github　→　ローカルリポジトリ
保存した内容の反映：ローカル　→　ワークツリー
上記の行為を他の開発者もそれぞれ行い、共同開発をおこなっている


ローカルの三つのエリア
ワークツリー
ステージ
コミットする内容を選択(追加)する場所。
githubDesktopではこのステージにコミットする変更内容を追加する作業が表では見えないように行われている
本来はコミットする内容をステージという場所にあげる作業が一つあるので、その違いに注意すること
ローカルリポジトリ


吉武一希
  2月17日 14:41
gitのデータ構造とその管理
ファイルの中身を圧縮したファイルをリポジトリに格納（その名前はハッシュ関数で設定した数文字列の羅列のようなものになっている）
ファイル名＋圧縮したファイル名(ファイル)をマッピングする
ファイルの中身を圧縮
インデックス（ステージにある？）にファイル名と圧縮したファイルのマッピングを行う
addコマンド：変更したい内容を準備する
裏側：ワークツリーでコミットしたい内容のデータの圧縮されたものがリポジトリに、ワークツリーのコミット対象のデータ名（ファイルなど）と、ワークツリーで圧縮したものがマッピングされたものが、インデックスの中に格納される
github desktopだとその一連の流れがコミットにより実施されるということですね？
コミットコマンド：変更内容のスナップショットを作成する
裏側：コミットを行うことでこれまでステージにためていた内容が、全てひとまとまりでスナップショットとして保存される
リポジトリの中にはaddで変更予定のワークツリーの変更内容を一時保存し、コミットをかけることで一時保存から保存に確定する
ツリーオブジェクト
エントリというキー：バリューのエントリという単位のリストを保持している
流れとしてはコミットのツリー名から、ツリーを参照し、ツリーのエントリのファイル名からリポジトリ内の圧縮されたファイルを参照しているという流れですか？
gitのadd~commitまでの内部動作から
ブロブオブジェクト：リポジトリに圧縮して格納されているワークツリーで変更したファイル。オブジェクト名はハッシュで一意に定められている
ツリーオブジェクト：ディレクトリと
git add コマンドを実行すると、その時点で変更されたファイルが圧縮されてブロブオブジェクトとして保存されます。一方、コミットを実行すると、Gitは現在のワークツリー全体をキャプチャして、ツリーオブジェクトを生成
インデックスに置かれているのは確定はしていないが、コミットされるとツリーオブジェクトになる情報
addコマンド実行
変更したファイルの圧縮された情報がリポジトリに一時的に保存される(ファイル名はハッシュで一意)
インデックスにツリーオブジェクトの仮情報となるものを一時的に保存する
commitの実行
インデックスの中にあるaddでためていた各情報をコミットオブジェクトの一部であるツリーオブジェクトとして生成される
一時仮置き：後でまた修正する


吉武一希
  2月17日 14:52
コミットを行った後、インデックスの内容はリセットされ、ワークツリーの現在の状態と一致するように更新されます。ただし、新しい変更を追加する際には、前のコミットの状態を基にインデックスが再構築されるため、そのために前のインデックスの情報が残っているように感じることがあります。
前の情報を使うような時、前の情報が何の変化もない場合は、その情報は次で生成されるツリーで含まれないという認識でよろしいですか　●
情報は含まれないが、前のツリーオブジェクトを参照するための親コミットの情報は持っているということですね？　●


吉武一希
  2月19日 12:06
変更して、圧縮されたブロブオブジェクトの参照を
ステージのインデックス内に複数の変更があり、それをコミット時にツリーオブジェクトとしたときにツリーオブジェクト内でそれぞれ作成したワークツリーで変更を加えるディレクトリ・ファイル名とそれをローカルで圧縮したブロブオブジェクトを参照するためのハッシュ値がリスト上で格納されているという認識ですがそれで良いですか？
基本的にツリーオブジェクトは変更したファイルに関連しているディレクトリなどをワークツリーのルートディレクトリからたどってそのディレクトリ構成で作成される
ツリーオブジェクトではディレクトリ・ファイル、各一つの単位で
ディレクトリはコミットした時点で、ツリーオブジェクトの一部としてハッシュ値に紐づいて生成。ファイルはブロブオブジェクトとして生成。それらをスナップショットしてまとめて保存しているという認識になりました
→ 変更がない限り、ブロブオブジェクトとそれに関連しているツリーオブジェクトのハッシュ値は変わらない。
ただし、表示的には毎回ワークツリー全体をスナップショットはしているようになっているが、内部では前回のコミットから変更されてない部分は、その前回分から引っ張ってきているだけなので注意
ディレクトリはコミット時にツリーオブジェクトとして保存され、ファイルはブロブオブジェクトとして保存されます。そして、それらがスナップショットとしてまとめて保存されることで、Gitは各コミット時点でのディレクトリ構造とファイル内容を正確に再現することができます。
まとめ
ディレクトリ: コミット時にツリーオブジェクトとして保存され、ハッシュ値に紐づけられます。
ファイル: ブロブオブジェクトとして保存され、その内容とハッシュ値がキャプチャされます。
スナップショット: ディレクトリ構造とファイル内容がスナップショットとしてまとめて保存されます。
 （編集済み） 


吉武一希
  2月20日 13:26
git initでは自身で作成するが、
リポジトリのコピー作成
いつもgit cloneなどでプロジェクトのテスト・開発環境などのコピーしていたので、実際に自身で作成するのはどうするのかは知らなかったので勉強になりました
git cloneは .gitディレクトリとリポジトリをコピーする
git add 変更をステージに追加する
ステージはコミットしてツリーオブジェクトを作成する前段階の場所。ステージに入っていないものは変更していてもコミット後に変更内容がスナップショットに反映されない。
addで全て変更しても、前のコミット内容と変化のないもの新しいコミットでも前のコミット内容がそのまま使われる（gitでは余計ない重複を避けるように設計されている）
変更を記録する：コミットするということ
スナップショットはコミット、ツリー、ブロブのその時点の変更内容などを全て保存したものと考えていて、それを参照するのにも、スナップショット自体のハッシュ値が必要ではないかと考えています　正解
作成されるスナップショットではワークツリーの詳細情報のコミットオブジェクトと変更内容を含んだワークツリーで必要な部分だけを作成する。そして全体として表す場合は、前回のコミットと合わせて出力する　正解
スナップショットのハッシュ値はコミットと同じもの
コミットメッセージはわかりやすく
推奨：変更内容の要約と理由は一行で書く
Gitではコミットメッセージを入力するためのエディタを設定することができるので、おすすめ
git status コマンドは、最新のワークツリーとステージの内容が前回のコミットと比較して変更点がないか確認ができるコマンド
Changes to be committed: ステージングエリアに追加されたが、まだコミットされていない変更。
Changes not staged for commit: ワークツリー内で変更されたが、まだステージングエリアに追加されていない変更。
Untracked files: ワークツリー内に存在するが、Gitによってまだ追跡されていないファイル。commitされていない新規ファイルのこと
コミット・ステージに追加する前にどんな変更をしたのか確認していく
実際の開発の際、ステージ追加やコミットする前にどのような変更をしたかを確認して実施する癖をつけておけば、大きな失敗にはつながらない


吉武一希
  2月21日 11:26
変更履歴の確認はgit logコマンドを活用する
オプションなしだと最新から最初までを上から順に全て表示
--onelineオプションでコミットハッシュ＋コミットメッセージを一行で表示する
-pオプションはファイル単位の変更差分を表示する
-p 表示したいファイル名
-n 表示するコミット数を最新から数えて制限する
-n 1 最新コミットのみ　-n 2 最新からもう一つ前まで
ファイルの削除を記録する
ファイルごと削除
git rm ファイル名
git rm -r ディレクトリ名
ワークツリーには残るがgitの管理から外れる。
git rm --cached ファイル名
コミット前の状態はリポジトリからは削除されたという変更内容のお知らせと、gitで管理していないファイルがあるとの知らせが同時にくる
addやrmなど変更に関わるコマンドは実行した段階でステージのインデックスにコマンドの処理とコンテンツが保存される
ファイルの移動を記録する
gitではファイル名の変更＝ファイルの移動という意味らしい
git mv 旧ファイル名 新ファイル名
githubへプッシュする
リモートをクローンした時、リモート自身(リモートのURL)を指すのにデフォルトではoriginと設定されている
新規でリモートリポジトリを追加する
リモートを指す
ローカルリポジトリをリモートへ新規追加
personal tokens
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

git hubアカウントの持ち主であることを認証するために利用するのもの
公開されているものは、ユーザー名とこちらだけで、リポジトリのクローンが可能だが、プライベートなものは事前招待・承認が必要になってくる
ちなみにユーザー名とトークンは利用する側のものであるため注意。利用者のユーザー名などではない


吉武一希
  2月21日 12:26
コマンドにエイリアスをつける
利用する理由：長ったらしいから簡略化
形式
git config --global alias.ci commit
config：設定変更するためのコマンド
--global ：pcにある全てローカルが適用される
設定関連でオプションをつけない場合は、現在利用しているローカルが適用範囲となる
バージョン管理をしないファイルをgitが最初から管理しないように.gitignoreファイルで管理する
実施することで該当のファイルが自動で削除されるし、gitの変更に反映されない
ignoreに設定する前にステージングされたものはステージングから下す必要がある
ファイルの変更を消す
必要性：ファイルの変更の取り消しをコマンド一つで簡単にできる
形式
git checkout -- ファイル名・ディレクトリ名、全変更など
内部的に起こっていること：checkoutで指定したファイルを前回コミットした同名のファイルの状態に上書きする
ステージの変更を取り消し
ステージングしたものを下ろしたい場合
形式
git reset HEAD ファイル名・ディレクトリ名、全変更など
内部的な動きはcheckoutの時とさして変わらないので割愛
直前のコミットをやり直す
コミットした内容に問題があり、それでやり直したい時に利用する
形式
git commit --amend
注意点
コマンドを行う前に、やり直してたい内容をステージングしておくこと
pushする前のコミットに限定すること
そうしないとpushしたものを他の開発者がプルした場合、修正後のものとプルした内容が合わなくなるため、次のような問題が起こる
コミット履歴の不一致：
他の開発者が pull した際、あなたが amend で修正したコミットと異なるコミットIDを持っているため、履歴が不一致となります。
これにより、マージコンフリクトが発生しやすくなります。

リモートリポジトリへのプッシュの失敗：
他の開発者が pull した後、リモートリポジトリに変更をプッシュしようとすると、コミット履歴の不一致のために push が拒否されることがあります。これにより、push を強制的に行う必要が生じ、さらに混乱を招く可能性があります。
もし上記の問題を行いたくない場合は、次のコミットを使いやり直すこと （編集済み） 


吉武一希
  2月21日 23:31
一つのローカルリポジトリに複数のリモートへの登録はできる
登録しているワークツリーからでしか、リモートとのやりとりはできない
複数リモートのプルではそれぞれの変更履歴が混ざる（統合）されるため
ブランチを切ることで複数プロジェクトを独立して管理する
その対応なしではプルした別のプロジェクトの内容が、別のプロジェクトにプッシュされ、リモート間で意図しない変更の共有がされてしまう
基本的にはプロジェクトごとに、ローカルリポジトリを作成して、それぞれでやりとりするほが混ざるリスクを解消できる
フェッチ：最新のリポジトリ情報(詳細ではなく、あくまで簡略化されたもの)が取得され、参照元であるリモートブランチも内容に伴い更新
プル：フェッチに加えて、ワークツリーへの取り込み（マージ）も自動的にやってくれる
プルでの注意点：統合先を間違えて指定して実行すると、コンフリクトや内容が混じってしまうなどの問題が起きるので、よくわからない場合などはfetch→margeを行うこと
リモートブランチ：リモートの各ブランチの最新状態を参照するためのアドレスを格納したもの。ローカルリポジトリに格納されている。フェッチが行われると、取得した最新のリモート情報をもとにしてリモートブランチも更新される